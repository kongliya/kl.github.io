# 面试总结：

面试中碰到的问题做个总结。

## call apply bind区别

call apply更改函数的调用者即this指向，此时 this指向的规则是不变的；

call：接受1~n个参数 ， 第一个参数为更改函数的调用者，其余的参数是从第二个开始和形参一一对应；
apply：接受两个参数 第一个参数为更改函数的调用者 第二个参数为一个数组 相当于arguments 数组里的项和形参一一对应；

bind后带括号 说明返回的是一个新的函数，必须调用才会执行 传参形式与call相同

## constructor || __proto__ || prototype 之间的区别

constructor 指向创建自己的构造函数；

每个函数之中都会有一个prototype 指向原型对象；

__proto__ 原型指针；指向构造自己的那个原型对象；

## ES7 新特性

1、求幂运算符 ( ** )
    
2、Array.prototype.includes()方法
查找一个值在不在数组里，若在，则返回true，反之返回false

两个参数：要搜索的值和搜索的开始索引，当第二个参数被传入时，该方法会从索引处开始往后搜索（默认搜索值为0）

3、函数作用域当中严格模式的变更

## ES8 新特性

异步函数：

Promise的写法只是回调函数的改进，使用then方法，只是让异步任务的两段执行更清楚而已。Promise的最大问题是代码冗余，请求任务多时，一堆的then，也使得原来的语义变得很不清楚。此时我们引入了另外一种异步编程的机制：Generator。
Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）

## http1.1 存在的问题

1. TCP连接数限制
    对于同一个域名，浏览器最多只能同时创建6~8 个TCP连接 为了解决数量限制 出现了域名分片技术 就是资源分域

2. 线头阻塞的问题
    每个TCP链接同时只能处理一个请求-响应，按照浏览器的FIFO原则处理请求，如果上一个响应没有返回 后续的请求-响应都会受阻。为了解决此问题 出现了管线化技术；

## js 三大组成部分

1、ECMAScript是一种规范

2、BOM 浏览器事件模型

3、DOM 文档对象模型

## jsonp的优缺点

优点：  
	1. 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；  
	2. 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或者ActiveX的支持；  
	3. 在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方。  

缺点：  
	1. 只支持get请求而不支持post等其他类型的http请求  
	2. 只支持跨域http请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题   
	3. jsonp在调动失败的时候不会返回各种http状态码  
	4. 安全性 假如提供jsonp的服务存在页面注入漏洞，即他返回的javascript内容是容易被人控制的。那么结果是所有调用这个jsonp的网站都会存在漏洞。  

所以在使用jsonp的时候一定要保证使用的jsonp服务是安全可靠的；  

## 继承
 
继承：  
分两种：  
构造函数继承：创建一个对象将想要继承的对象和方法放进去；  
实现：call apply 更改this的指向 直接更改父级的this指向当前的调用者  

原型继承：每个构造函数 都有一个原型对象 而原型有个特性 在for in 的时候会隐藏掉两个属性 constructor __proto__所以我们for in 到的只是自己添加的属性和方法；所以此时我们就可以将父级的prototype直接通过for in给子级；  

## 内存泄漏 实现延迟加载的方式

什么是内存泄漏？  
内存泄漏可以定义为：应用程序不需要占用内存的时候，内存没有被系统回收或可用内存池回收。  

内存泄漏出现的几种情况  
JavaScript·是一种垃圾回收语言。  

1、意外的全部变量污染。  
解决方式：使用use strict严格模式，避免意外的全局变量，或者解除引用，令其=null.  
2、被遗忘的定时器或回调函数  
定时器无法随着函数的结束而停止，所以要要停止定时器从而使定时器从内存中清理出去  
3、脱离DOM的引用  
假如你的代码中保存了表格某一个td的引用，当你决定删除整个表格的时候，直觉认为会回收除了已保存的td意外的其他节点，实际情况是td是表格的子节点，子元素和父元素是引用关系，由于代码保存了td的引用，导致整个表格仍待在内存中。  
4、闭包  
解除引用  

JS  延迟加载的方式  
1、defer属性   和async一样都是写在scrip标签上比如
```
<script defer='defer'>  
```
2、async属性  
3、动态创建DOM方式  
4、jQuery的getScript（）方法  
5、使用setTimeout延迟  
6、把JS放到页面底部，让JS最后引入  

## 判断一个数据类型是什么类型的
```
object.prototype.toString().call
```

## 输入www.baidu.com会发生什么

1、域名解析  
2、找到相对应的服务器  
3、找到相对应的资源  
4、返回相对应的资源  
5、浏览器对资源进行解析，比如html，js，css，img，将会再次找到对应的服务器，找到资源并返回  
6、返回到客户端  

## 伪数组转真数组

原生四种方法：  

1、最简单的 声明一个空数组 通过遍历伪数组把他们添加到新的数组中种 （不是面试官要的 大家都会）；  
2、使用数组的slice方法 它返回的数组 使用call 或者 apply指向伪数组；  
3、使用原型继承；
```
li.__proto__ = Array.prototype；
```
4、ES6数组的新方法：Array.from()；  
缺点 兼容性不好；